\documentclass[a4paper,11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[justification=centering,labelfont=bf]{caption}
\usepackage[hidelinks]{hyperref}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{soul}
\usepackage{listings}

\newcommand{\CodeSymbol}[1]{\textcolor{brown}{#1}}
\lstdefinelanguage{hal}{
    basicstyle=\ttfamily,
    sensitive=true,
    morestring=[b]",
    keywords=[1]{for,in,while,if,else,elif,class,def,with,return,import,from},
    keywords=[2]{Array, print, self, yield, block_given?},
    keywordstyle=[1]\color{blue},
    keywordstyle=[2]\color{red!60!black},
    ={\color{brown!50!black}\bfseries},
    morecomment=[l]{\#},
    showstringspaces=false,
    stringstyle=\color{green!50!black},
    captionpos=b,
    literate=%
      {\{}{{\CodeSymbol{\{}}}1
      {\}}{{\CodeSymbol{\}}}}1
      {(}{{\CodeSymbol{(}}}1
      {)}{{\CodeSymbol{)}}}1
      {>}{{\CodeSymbol{>}}}1
      {<}{{\CodeSymbol{<}}}1
      {=}{{\CodeSymbol{=}}}1
      {;}{{\CodeSymbol{;}}}1
      {[}{{\CodeSymbol{[}}}1
      {]}{{\CodeSymbol{]}}}1
      {:}{{\CodeSymbol{:}}}1
      {.}{{\CodeSymbol{.}}}1
      {+}{{\CodeSymbol{+}}}1
      {-}{{\CodeSymbol{-}}}1
      {`}{{\CodeSymbol{\`{}}}}1
  }
\lstdefinelanguage{output}{
  basicstyle=\ttfamily\footnotesize,
  columns=fullflexible,
  backgroundcolor=\color{gray!180!black},
  xleftmargin=0.5cm,frame=tlbr,framesep=4pt,framerule=0pt
  }
\begin{document}
\begin{titlepage}
\begin{center}
\textsc{\Large Compilers}
\\[1.5cm]
\rule{\linewidth}{0.5mm}
\\[0.4cm]
{\huge
\bfseries
HAL
\\[0.4cm]
}
\rule{\linewidth}{0.5mm}
\\[2.5cm]
\begin{minipage}{0.4\textwidth}
\begin{flushleft}
\large
Héctor Ramón Jiménez
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright}
\large
Alvaro Espuña Buxo
\end{flushright}
\end{minipage}
\vfill
{\large
\today
}
\\
{\large
\texttt{Facultat d'Informàtica de Barcelona}
}
\end{center}
\end{titlepage}
\tableofcontents
\clearpage
\section{Introduction}
Programming languages are the most important tools of a programmer. [...]
Our main objective was to create a programming language we would find \textbf{useful} in the future.
  With that in mind we have developed \texttt{HAL}, an scripting language that features:
\begin{itemize}
\item
A \textbf{clean} syntax, perfect for creating \textbf{D}omain-\textbf{S}pecific \textbf{L}anguages
\item
A \textbf{consistent} object-oriented architecture with \textbf{inheritance}
\item
Dynamic typing and \textbf{duck typing}
\item
Builtin methods that can be \textbf{rewritten} in \texttt{HAL} itself
\item
\textbf{Module} imports
\item
\textbf{First-class} \st{functions} methods
\item
...
\item
An \textbf{extensible}, \textbf{intuitive} and \textbf{interactive} interpreter
\end{itemize}
We love \texttt{Python} and \texttt{Ruby}! In fact, most of the features of \texttt{HAL} are directly influenced
  by these two languages. However, we implemented everything in our own way, thinking in our
  needs as programmers and what made sense to include in \texttt{HAL}.
\begin{figure}[h!]
\begin{lstlisting}[language=hal]
5.times: print "Hello world!"
\end{lstlisting}
\begin{lstlisting}[language=output]
Hello world!
Hello world!
Hello world!
Hello world!
Hello world!
\end{lstlisting}
\caption{HAL says: ``Hello world!"}
\label{hello5}
\end{figure}
\clearpage
\section{Features}
\subsection{Clean syntax}
\texttt{HAL} can be easily used to create \textbf{D}omain-\textbf{S}pecific \textbf{L}anguages! Parentheses in calls are optional, \texttt{self}
  is implicitly set accordingly to the \textbf{scope} and \textbf{blocks} can be defined easily with indentation!
\begin{figure}[h!]
\begin{lstlisting}[language=hal]
class Array:
  def sort!:
    return self if size < 2
    p = first
    q = pop!
    lesser = q.filter with x: x < p
    greater = q.filter with x: x >= p
    lesser.sort! ++ [p] ++ greater.sort!

a = [1, 2, 3, -1, -2, -3, 20, 40, 1, 2, 200, -5]
print a.sort!
\end{lstlisting}
\begin{lstlisting}[language=output]
[-5, -3, -2, -1, 1, 1, 2, 2, 3, 20, 40, 200]
\end{lstlisting}
\caption{\texttt{HAL} can quicksort!}
\label{quicksort}
\end{figure}
\subsection{Everything is an object}
That's why we said that \texttt{HAL} has a consistent object-oriented architecture. Even \texttt{none} is an object!
\begin{figure}[h!]
\begin{lstlisting}[language=hal]
print \
  1.add(2), Array.new, "Chunky bacon!".size,
  range(10).sum, &range.arity, Class.repr, none.none?
\end{lstlisting}
\begin{lstlisting}[language=output]
3
[]
13
45
1
Class
true
\end{lstlisting}
\caption{Objects everywhere}
\label{objects}
\end{figure}
\\
All the instructions return objects in \texttt{HAL}. The value returned by the last instruction of a method
  is the returned value of the method.
\subsection{Every method can be overriden}
Like in \texttt{Python} there is no method visibility
  concept, which means that all methods can be called from everywhere. Also, like in \texttt{Ruby}
  any class can be reopened at any moment to define or override methods. There is even possible to
  override builtin methods\footnote{Native methods written in Java.}!
\begin{figure}[h!]
\begin{lstlisting}[language=hal]
def concat: range(10) ++ range(20, start => 10)

print concat

class Array:
  def __concat__ x:
    x.each with index, element:
      self[index] = self[index] + element
    self

print concat
\end{lstlisting}
\begin{lstlisting}[language=output]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]
[10, 12, 14, 16, 18, 20, 22, 24, 26, 28]
\end{lstlisting}
\caption{Overriding \texttt{Array} concatenation!}
\label{overrides}
\end{figure}
\clearpage
\subsection{Blocks}
Like in \texttt{Ruby}, it is possible to pass blocks to methods. However, in \texttt{HAL} you can define the
  block using the ``\texttt{:}" keyword and indenting accordingly. In a method, the names \texttt{block\_given?}
  and \texttt{yield} are set accordingly to whether some block was given or not.
\begin{figure}[h!]
\begin{lstlisting}[language=hal]
def list title => none, numbered? => false:
  print "<h1>" + title + "</h1>" if not title.none?
  print "<ol>" if numbered? else print "<ul>"
  yield
  print "</ol>" if numbered? else print "</ul>"

def item x:
  if block_given?:
  	print "<li>" + x
  	yield
  	print "</li>"
  else:
    print "<li>" + x + "</li>"

list "Shopping list":
  item "Meat":
    list:
      item "Bacon"
  item "Vegetables":
    list numbered? => true:
      item "Cabbage"
      item "Cucumber"
\end{lstlisting}
\begin{lstlisting}[language=output]
<h1>Shopping list</h1>
<ul>
<li>Meat
<ul>
<li>Bacon</li>
</ul>
</li>
<li>Vegetables
<ol>
<li>Cabbage</li>
<li>Cucumber</li>
</ol>
</li>
</ul>
\end{lstlisting}
\caption{Generating HTML lists with \texttt{HAL}!}
\label{blocks}
\end{figure}
\subsection{First-class methods}
Methods are objects too! The \texttt{\&} accessor can be used to avoid calling and obtain the
  value stored under that name itself.
\begin{figure}[h!]
\begin{lstlisting}[language=hal]
def lambda: &yield

add = lambda with x, y: x + y

print add 5, add 3, add 1, 2
print &add.arity
\end{lstlisting}
\begin{lstlisting}[language=output]
11
2
\end{lstlisting}
\caption{Creating lambdas in one line of code!}
\label{first_class_methods}
\end{figure}
\subsection{Module imports}
Like in \texttt{Python} every file that contains code is a \textbf{module}. Modules can be imported inside
  other modules using the \texttt{import} statement.
\begin{figure}[h!]
\begin{lstlisting}[language=hal]
print "Loading examples..."
print "-------------------"
import examples.quicksort
from examples.scope import Foo
print "-------------------"
print Foo.new
\end{lstlisting}
\begin{lstlisting}[language=output]
Loading examples...
-------------------
[-5, -3, -2, -1, 1, 1, 2, 2, 3, 20, 40, 200]
Class variable
Instance variable
Module variable
Class variable
Another module variable
-------------------
Class variable
\end{lstlisting}
\caption{Importing some examples}
\label{import}
\end{figure}
\clearpage
\subsection{Four levels of scopes}
\texttt{HAL} has four different variable scopes. Variables can be defined in those scopes
  using different access operators:
\begin{description}
\item[Local]
Without any accessor
\item[Instance]
Using the ``\texttt{@}" accessor
\item[Static]
Using the ``\texttt{@@}" accessor
\item[Module]
Instance variables defined in the current module
\end{description}
When a name is referenced without any accessor, \texttt{HAL} searches it following that order.
\begin{figure}[h!]
\begin{lstlisting}[language=hal]
@m = "Module variable"

class Foo:
  @a = "Class variable"

  def init:
    @a = "Instance variable"
    @m = m

  def __str__:
    @@a

print Foo.a, Foo.new.a, Foo.new.m, Foo.new

@m = "Another module variable"

print Foo.new.m
\end{lstlisting}
\begin{lstlisting}[language=output]
Class variable
Instance variable
Module variable
Class variable
Another module variable
\end{lstlisting}
\caption{}
\label{scope}
\end{figure}
\clearpage
\subsection{Inheritance}
\textbf{Objects can inherit methods from other objects!} The name \texttt{super} contains a reference to the method
  with the same name implemented by the parent class, if there is any. The \texttt{init} method is called after
  instantiating an object.
\begin{figure}[h!]
\begin{lstlisting}[language=hal]
class Animal:
  def init type:
    @type = type

  def __str__:
    "A " + @type

class Fox << Animal:
  def init name:
    super "fox"
    @name = name

  def __str__:
    super + " named " + @name

print Animal.new "horse"
print Fox.new "Tod"
\end{lstlisting}
\begin{lstlisting}[language=output]
A horse
A fox named Tod
\end{lstlisting}
\caption{The tale of Tod and the horse with no name}
\label{inheritance}
\end{figure}
\clearpage
\subsection{Execution of shell commands}
Command shells can be executed using \textbf{backticks} (\texttt{\`}). The value returned is the output
  of the execution. Additionally, it is possible to use the class \texttt{Process} to have information
  about the \textbf{exit status} and the \textbf{error output}.
\begin{figure}[h!]
\begin{lstlisting}[language=hal]
File.open "test.txt" with f:
  f.write "Writing a file has never been so easy!"

print `cat test.txt`
\end{lstlisting}
\begin{lstlisting}[language=output]
Writing a file has never been so easy!
\end{lstlisting}
\caption{Writing a file and showing its contents}
\label{backticks}
\end{figure}
\clearpage
\section{Syntax}
We wanted \texttt{HAL} to be \textbf{readable}, \textbf{clean} and \textbf{easy to write}. We think that one of the
  best features of \texttt{Python} is the way it defines blocks by indentation because it forces the programmer
  to write readable code! On the other hand, \texttt{Python} is really verbose sometimes: explicit \texttt{self} everywhere,
  calls with mandatory parentheses... Here's where \texttt{Ruby} wins! The syntax of \texttt{Ruby} lets the programmer
  decide whether to be \textbf{explicit} or not, producing code that can feel like \emph{magic}.
\\
We decided to try to combine the best parts of \texttt{Python} and \texttt{Ruby} syntaxes into \texttt{HAL}. The result
  is an amazingly \textbf{clean} syntax with \textbf{blocks defined by indentation} and letting the programmer
  be \textbf{explicit only when necessary}!
\clearpage
\section{Interpreter}
\subsection{Builtin methods}
There are two name references for every builtin provided with the interpreter: one that is
  surrounded with ``\texttt{\_\_}" (double underscores) and another that is not (\texttt{\_\_range\_\_} and \texttt{range} for example).
  The name surrounded with underscores is the one that the interpreter can use internally in case it needs it.
  This means that overriding this methods you can get in the way of how the interpreter does things and use it
  at your favour. For example, you can filter arrays on creation overriding the \texttt{\_\_append!\_\_} method (see Figure
  \ref{override_append}). The reference without underscores is provided for readability purposes and as a backup.
\begin{figure}[h!]
\begin{lstlisting}[language=hal]
def ugly_array: [1, 2, [], [], 3, [[]], 4, 5, 6]

print ugly_array

class Array:
  def __append!__ x:
    append! x if x != [] else self

print ugly_array
\end{lstlisting}
\begin{lstlisting}[language=output]
[1, 2, [], [], 3, [[]], 4, 5, 6]
[1, 2, 3, 4, 5, 6]
\end{lstlisting}
\caption{Filtering empty \texttt{Array}s on construction}
\label{override_append}
\end{figure}
\end{document}
