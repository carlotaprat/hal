from input import Keyboard
from opengl import display, draw, projection, ortho, disable, clear, DEPTH_TEST, color, line
from tetris.pieces import random_piece, Square


class Player:
  @keys = [ Keyboard.KEY_LEFT, Keyboard.KEY_RIGHT, Keyboard.KEY_DOWN, Keyboard.KEY_UP,
    Keyboard.KEY_SPACE ]
  @limit_input = 20
  
  # Key status
  @UP = 0
  @DOWN = 1
  @DOWN_MOVED = 2
  @DOWN_RELEASED = 3
  @DOWN_KEPT = 4


  def init board:
    @board = board
    @time_still = 0
    @infinity = 500
    @time_key = 0
    @key_status = {}
    @key_times = {}
    @drop = false

    for key in @@keys:
      @key_status[key] = @@UP
      @key_times[key] = -1

    new_piece!

  def new_piece!:
    @piece = random_piece.new @board

  def update delta:
    @time_still = @time_still + delta
    @time_key = @time_key + delta

    for key, status in @key_status:
      if Keyboard.down? key:
        @key_status[key] = @@DOWN if status == @@UP
        
        if status == @@DOWN_MOVED:
          if @key_times[key] == -1:
            @key_times[key] = -delta
          else:
            @key_times[key] = @key_times[key] + delta

          if @key_times[key] > @@limit_input * 5:
            @key_status[key] = @@DOWN_KEPT

      else:
        @key_times[key] = -1

        if status == @@DOWN:
          @key_status[key] = @@DOWN_RELEASED
        elif status == @@DOWN_MOVED or status == @@DOWN_KEPT:
          @key_status[key] = @@UP

    if board.busy?:
      board.update

    elif @drop == false:
      process_keys! if @time_key > @@limit_input

      if @time_still > @infinity:
        @time_still = @time_still - @infinity
        new_piece! if not piece.down!

    else:
      falling = piece.down!
      falling = piece.down! if falling

      if not falling:
        new_piece!
        @drop = false

  def process_keys!:
    @time_key = @time_key - @@limit_input

    for key, status in @key_status:
      if status != @@DOWN_MOVED and status != @@UP:
        # Update key status accordingly
        if status == @@DOWN:
          @key_status[key] = @@DOWN_MOVED

        elif status == @@DOWN_RELEASED:
          @key_status[key] = @@UP

        # TODO: Implement native HAL switch (Ruby-like)
        if key == Keyboard.KEY_LEFT:
          piece.left!

        elif key == Keyboard.KEY_RIGHT:
          piece.right!

        elif key == Keyboard.KEY_DOWN:
          @time_still = 0
          new_piece! if not piece.down!

        elif key == Keyboard.KEY_UP:
          piece.rotate_left!

        elif key == Keyboard.KEY_SPACE:
          @drop = true if status == @@DOWN or status == @@DOWN_RELEASED


class Board:
  @hcells = 10
  @vcells = 20
  @width = @hcells * Square.width
  @height = @vcells * Square.width

  def init:
    @cells = [ [ none for _ in range(@@hcells) ] for _ in range(@@vcells) ]
    @row_count = [ 0 for _ in range(@@vcells) ]
    @clear_queue = []

  def add! squares:
    for square in squares:
      if square.y >= 0:
        @cells[square.y][square.x] = square
        @row_count[square.y] = @row_count[square.y] + 1 # TODO: Add native += operator
        @clear_queue.append! square.y if @row_count[square.y] == 10

    @clear_queue.sort!

  def busy?:
    @clear_queue != []

  def update:
    print @clear_queue
    row = @clear_queue.first
    @clear_queue.pop!

    # Move cells down
    for i in range(row, 1):
      current = row - i
      @row_count[current+1] = @row_count[current]

      for index, cell in @cells[current]:
        @cells[current+1][index] = cell
        cell.y = cell.y + 1 if not cell.none?

    # Clear first row
    @cells[0] = [ none for _ in range(@@hcells) ]


  def taken? x, y:
    y >= 0 and (x < 0 or x >= @@hcells or y >= @@vcells or not @cells[y][x].none?)

  def render:
    for row in @cells:
      for cell in row:
        cell.render if not cell.none?

    color 0.2, 0.2, 0.2

    for i in range(@@hcells):
      line i * Square.width, 0, i * Square.width, @@height

    for i in range(@@vcells):
      line 0, i * Square.width, @@width, i * Square.width


def play:
  display title => "HALtris", width => Board.width, height => Board.height:
    # Initialize OpenGL
    projection: ortho 0, Board.width, Board.height, 0, 0, 1
    disable DEPTH_TEST

    board = Board.new
    player = Player.new board

    draw fps => 60 with delta:
      clear
      
      # Update game logic
      player.update delta

      # Render objects
      player.piece.render
      board.render
      
play
