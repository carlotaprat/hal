from input import Keyboard
from opengl import display, draw, projection, ortho, disable, clear, DEPTH_TEST, color, line
from tetris.pieces import random_piece, Square


class Player:
  @keys = [ Keyboard.KEY_LEFT, Keyboard.KEY_RIGHT, Keyboard.KEY_DOWN, Keyboard.KEY_UP ]
  @limit_input = 20
  
  # Key status
  @UP = 0
  @DOWN = 1
  @DOWN_MOVED = 2
  @DOWN_RELEASED = 3
  @DOWN_KEPT = 4


  def init board:
    @board = board
    @time_still = 0
    @infinity = 500
    @time_key = 0
    @key_status = {}
    @key_times = {}

    for key in @@keys:
      @key_status[key] = @@UP
      @key_times[key] = -1

    new_piece!

  def new_piece!:
    @piece = random_piece.new @board

  def update delta:
    @time_still = @time_still + delta
    @time_key = @time_key + delta

    for key, status in @key_status:
      if Keyboard.down? key:
        @key_status[key] = @@DOWN if status == @@UP
        
        if status == @@DOWN_MOVED:
          if @key_times[key] == -1:
            @key_times[key] = -delta
          else:
            @key_times[key] = @key_times[key] + delta

          if @key_times[key] > @@limit_input * 5:
            @key_status[key] = @@DOWN_KEPT

      else:
        @key_times[key] = -1

        if status == @@DOWN:
          @key_status[key] = @@DOWN_RELEASED
        elif status == @@DOWN_MOVED or status == @@DOWN_KEPT:
          @key_status[key] = @@UP

    process_keys! if @time_key > @@limit_input

    if @time_still > @infinity:
      @time_still = @time_still - @infinity
      new_piece! if not piece.down!

  def process_keys!:
    @time_key = @time_key - @@limit_input

    for key, status in @key_status:
      if status != @@DOWN_MOVED and status != @@UP:
        # Update key status accordingly
        if status == @@DOWN:
          @key_status[key] = @@DOWN_MOVED

        elif status == @@DOWN_RELEASED:
          @key_status[key] = @@UP

        # TODO: Implement native HAL switch (Ruby-like)
        if key == Keyboard.KEY_LEFT:
          piece.left!

        elif key == Keyboard.KEY_RIGHT:
          piece.right!

        elif key == Keyboard.KEY_DOWN:
          @time_still = 0
          new_piece! if not piece.down!

        elif key == Keyboard.KEY_UP:
          piece.rotate_left!


class Board:
  @hcells = 10
  @vcells = 20
  @width = @hcells * Square.width
  @height = @vcells * Square.width

  def init:
    @cells = [ [ none for _ in range(@@hcells) ] for _ in range(@@vcells) ]

  def add! squares:
    for square in squares:
      @cells[square.y][square.x] = square

  def taken? x, y:
    y >= 0 and (x < 0 or x >= @@hcells or y >= @@vcells or not @cells[y][x].none?)

  def render:
    for row in @cells:
      for cell in row:
        cell.render if not cell.none?

    color 0.2, 0.2, 0.2

    for i in range(@@hcells):
      line i * Square.width, 0, i * Square.width, @@height

    for i in range(@@vcells):
      line 0, i * Square.width, @@width, i * Square.width


def play:
  display title => "HALtris", width => Board.width, height => Board.height:
    # Initialize OpenGL
    projection: ortho 0, Board.width, Board.height, 0, 0, 1
    disable DEPTH_TEST

    board = Board.new
    player = Player.new board

    draw fps => 60 with delta:
      clear
      
      # Update game logic
      player.update delta

      # Render objects
      player.piece.render
      board.render
      
play
